diff --git a/contracts/AlowanceModule.sol b/contracts/AlowanceModule.sol
index 41c3eb8ca02cd5dbefffff7f3211057c9d7cac0b..52acbc8eef29fdb7417e6ac0c708ae92cf08c488 100644
--- a/contracts/AlowanceModule.sol
+++ b/contracts/AlowanceModule.sol
@@ -69,26 +69,32 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
 
     // The allowance info is optimized to fit into one word of storage.
     struct Allowance {
-        uint96 amount;
+        uint256 fiatAmount;
+        uint96 tokenAmount;
         uint96 spent;
+        uint16 nonce;
         uint16 resetTimeMin; // Maximum reset time span is 65k minutes
         uint32 lastResetMin;
-        uint16 nonce;
-        int256 endsOn;
+        int8 endsOn;
     }
 
-    int256 public immutable notEndsOn = -1;
+    int8 public immutable notEndsOn = -1;
+    uint256 public gasCost = 1e6;
+    uint256 public one_ether = 1e18;
+    uint256 public priceTimeThresold = 2 days;
 
     event AddDelegate(address indexed safe, address delegate);
     event RemoveDelegate(address indexed safe, address delegate);
     event ExecuteAllowanceTransfer(address indexed safe, address delegate, address token, address to, uint96 value, uint16 nonce);
     event PayAllowanceTransfer(address indexed safe, address delegate, address paymentToken, address paymentReceiver, uint96 payment);
-    event SetAllowance(address indexed safe, address delegate, address token, uint96 allowanceAmount, uint16 resetTime);
+    event SetAllowance(address indexed safe, address delegate, address token, uint96 tokenAmount, uint256 fiatAmount, uint16 resetTime);
     event ResetAllowance(address indexed safe, address delegate, address token);
     event DeleteAllowance(address indexed safe, address delegate, address token);
     event NewMaxGasPrice(address indexed safe, uint256 newMaxGasPrice);
     event AddTokenOracle(address indexed token, address indexed oracle);
     event SetGelatoAddress(address indexed gelato);
+    event SetGasCost(uint256 gasCost);
+    event SetPriceThresold(uint256 priceTimeThresold);
 
     constructor(address payable _gelato) {
         GELATO = _gelato;
@@ -97,12 +103,13 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
     /// @dev Allows to update the allowance for a specified token. This can only be done via a Safe transaction.
     /// @param delegate Delegate whose allowance should be updated.
     /// @param token Token contract address.
-    /// @param allowanceAmount allowance in smallest token unit.
+    /// @param tokenAmount allowance in smallest token unit.
+    /// @param fiatAmount allowance in fiat.
     /// @param resetTimeMin Time after which the allowance should reset
     /// @param resetBaseMin Time based on which the reset time should be increased
     function setAllowance(
-        address delegate, address token, uint96 allowanceAmount, int256 fiatAmount, 
-        uint16 resetTimeMin, uint32 resetBaseMin, int256 endsOn
+        address delegate, address token, uint96 tokenAmount, uint256 fiatAmount, 
+        uint16 resetTimeMin, uint32 resetBaseMin, int8 endsOn
     )
         public
     {
@@ -125,14 +132,10 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
         }
         allowance.resetTimeMin = resetTimeMin;
 
-        if (allowanceAmount != 0) {
-            allowance.amount = allowanceAmount;
+        if (tokenAmount > 0) {
+            allowance.tokenAmount = tokenAmount;
         } else {
-            require(fiatAmount != 0, "Fiat Amount Can't be Zero");
-            require(tokenToOracle[token] != address(0), "Oracle not specified for this token");
-            uint96 tokenQuantity = getTokenQuantity(fiatAmount, token, tokenToOracle[token]);
-            require(tokenQuantity != 0, "Token Quantity Can't be Zero");
-            allowance.amount = tokenQuantity;
+            allowance.fiatAmount = fiatAmount;
         }
 
         if (endsOn > 0) {
@@ -142,28 +145,30 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
         }
 
         updateAllowance(msg.sender, delegate, token, allowance);
-        emit SetAllowance(msg.sender, delegate, token, allowanceAmount, resetTimeMin);
+        emit SetAllowance(msg.sender, delegate, token, tokenAmount, fiatAmount, resetTimeMin);
     }
 
     // calculate token quantity from fiat amount
-    function getTokenQuantity(int256 fiatAmount, address token, address _oracle)
+    function getTokenQuantity(uint256 fiatAmount, address token, address _oracle)
         public view returns(uint96 tokenQuantity)
     {
         // Call Chainlink to fetch price and priceDecimals
         (int tokenPrice, uint256 priceDecimals) = getLatestPrice(_oracle);
         uint256 tokenDecimals = IERC20Decimal(token).decimals();
-
-        fiatAmount = fiatAmount * int256(10 ** priceDecimals);
-        tokenQuantity = uint96(wdiv(uint(fiatAmount), uint(tokenPrice)));
+        uint256 totalFiatAmountInDec = fiatAmount * (10 ** priceDecimals);
+        tokenQuantity = uint96(wdiv(totalFiatAmountInDec, uint(tokenPrice)));
         if (tokenDecimals != 18) {
-            tokenQuantity = uint96(tokenQuantity * (10 ** tokenDecimals) / (10 ** 18));
+            tokenQuantity = uint96(tokenQuantity * (10 ** tokenDecimals) / (one_ether));
         }
     }
 
     // chainlink price integration
     function getLatestPrice(address _oracle) public view returns (int, uint8) {
-        (,int price,,,) = AggregatorV3Interface(_oracle).latestRoundData();
+        (,int price,,uint timeStamp,) = AggregatorV3Interface(_oracle).latestRoundData();
+        require(price > 0, "Prize should not be negative.");
         uint8 decimals = AggregatorV3Interface(_oracle).decimals();
+        uint256 timeDiff = block.timestamp - timeStamp;
+        require(timeDiff < priceTimeThresold, "Timestamp is old");
         return (price, decimals);
     }
 
@@ -201,7 +206,8 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
         public
     {
         Allowance memory allowance = getAllowance(msg.sender, delegate, token);
-        allowance.amount = 0;
+        allowance.tokenAmount = 0;
+        allowance.fiatAmount = 0;
         allowance.spent = 0;
         allowance.resetTimeMin = 0;
         allowance.lastResetMin = 0;
@@ -228,28 +234,42 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
     ) public {
         // Get current state
         Allowance memory allowance = getAllowance(address(safe), delegate, token);
-        bytes memory transferHashData = generateTransferHashData(address(safe), token, to, amount, allowance.nonce);
 
         if (allowance.endsOn != notEndsOn) {
             require(allowance.endsOn > 0, "This address's recurring expired.");
             allowance.endsOn = allowance.endsOn - 1;
         }
 
-        // Update state
-        allowance.nonce = allowance.nonce + 1;
+        uint96 tokenQuantity;
         uint96 newSpent = allowance.spent + amount;
-        // Check new spent amount and overflow
-        require(newSpent > allowance.spent && newSpent <= allowance.amount, "newSpent > allowance.spent && newSpent <= allowance.amount");
+        if (allowance.fiatAmount > 0) {
+            // Calculate TokenQunatity from fiatAmount(amount)
+            require(tokenToOracle[token] != address(0), "Oracle not specified for this token");
+            uint96 tokenQuantity = getTokenQuantity(amount, token, tokenToOracle[token]);
+            require(tokenQuantity != 0, "Token Quantity Can't be Zero");
+
+            // Check new spent fiatAmount and overflow
+            require(newSpent > allowance.spent && newSpent <= allowance.fiatAmount, "newSpent > allowance.spent && newSpent <= allowance.fiatAmount");
+
+        } else {
+            tokenQuantity = amount;
+
+            // Check new spent tokenQuantity and overflow
+            require(newSpent > allowance.spent && newSpent <= allowance.tokenAmount, "newSpent > allowance.spent && newSpent <= allowance.tokenAmount");
+        }
         allowance.spent = newSpent;
+        bytes memory transferHashData = generateTransferHashData(address(safe), token, to, tokenQuantity, allowance.nonce);
+
+        allowance.nonce = allowance.nonce + 1;
         updateAllowance(address(safe), delegate, token, allowance);
 
         // Perform external interactions
         // Check signature
         checkSignature(delegate, signature, transferHashData, safe);
 
-        if (payment > 0) {
+        if (payment > 0 && msg.sender == GELATO) {
             require(tx.gasprice <= maxGasPrice[address(safe)], "tx.gasprice is > maxGas price");
-            require(payment <= maxGasPrice[address(safe)] * 1e6, "Gas fees > allowed"); // deterministic gas calculation
+            require(payment <= maxGasPrice[address(safe)] * gasCost, "Gas fees > allowed"); // deterministic gas calculation
             // Transfer payment
             // solium-disable-next-line security/no-tx-origin
             transfer(safe, ETH, GELATO, payment);
@@ -257,8 +277,8 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
             emit PayAllowanceTransfer(address(safe), delegate, ETH, tx.origin, payment);
         }
         // Transfer token
-        transfer(safe, token, to, amount);
-        emit ExecuteAllowanceTransfer(address(safe), delegate, token, to, amount, allowance.nonce - 1);
+        transfer(safe, token, to, tokenQuantity);
+        emit ExecuteAllowanceTransfer(address(safe), delegate, token, to, tokenQuantity, allowance.nonce - 1);
     }
 
     /// @dev Allows to use the allowance to perform a transfer to multiple users.
@@ -278,6 +298,9 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
         address[] memory delegate,
         bytes[] memory signature
     ) public {
+        require(amount.length == safe.length && amount.length == token.length 
+            && amount.length == to.length && amount.length == payment.length 
+            && amount.length == delegate.length && amount.length == signature.length, "Array length mismatch");
         uint256 countToIterate = amount.length;
         for (uint i=0; i<countToIterate; i++) {
             executeAllowanceTransfer(safe[i], token[i], payable(to[i]), amount[i], payment[i], delegate[i], signature[i]);
@@ -374,13 +397,23 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
 
     function getTokenAllowance(address safe, address delegate, address token) public view returns (uint256[5] memory) {
         Allowance memory allowance = getAllowance(safe, delegate, token);
-        return [
-            uint256(allowance.amount),
-            uint256(allowance.spent),
-            uint256(allowance.resetTimeMin),
-            uint256(allowance.lastResetMin),
-            uint256(allowance.nonce)
-        ];
+        if (allowance.tokenAmount > 0) {
+            return [
+                uint256(allowance.tokenAmount),
+                uint256(allowance.spent),
+                uint256(allowance.resetTimeMin),
+                uint256(allowance.lastResetMin),
+                uint256(allowance.nonce)
+            ];
+        } else {
+            return [
+                uint256(allowance.fiatAmount),
+                uint256(allowance.spent),
+                uint256(allowance.resetTimeMin),
+                uint256(allowance.lastResetMin),
+                uint256(allowance.nonce)
+            ];
+        }
     }
 
     /// @dev Allows to add a delegate.
@@ -422,7 +455,8 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
                 address token = delegateTokens[i];
                 // Set all allowance params except the nonce to 0
                 Allowance memory allowance = getAllowance(msg.sender, delegate, token);
-                allowance.amount = 0;
+                allowance.tokenAmount = 0;
+                allowance.fiatAmount = 0;
                 allowance.spent = 0;
                 allowance.resetTimeMin = 0;
                 allowance.lastResetMin = 0;
@@ -461,12 +495,26 @@ contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
     }
 
     function addTokenOracle(address token, address oracle) public onlyOwner {
+        require(token != address(0) && oracle != address(0), "Address Can't be Zero");
         tokenToOracle[token] = oracle;
         emit AddTokenOracle(token, oracle);
     }
 
     function setGelatoAddress(address payable gelato) public onlyOwner {
+        require(gelato != address(0), "Address Can't be Zero");
         GELATO = gelato;
         emit SetGelatoAddress(gelato);
     }
+
+    function setGasCost(uint256 _gasCost) public onlyOwner {
+        require(_gasCost > 0, "Gas Cost Can't be Zero");
+        gasCost = _gasCost;
+        emit SetGasCost(gasCost);
+    }
+
+    function setPriceThresold(uint256 _thresold) public onlyOwner {
+        require(_thresold > 0, "Price thresold Can't be Zero");
+        priceTimeThresold = _thresold;
+        emit SetPriceThresold(priceTimeThresold);
+    }
 }
