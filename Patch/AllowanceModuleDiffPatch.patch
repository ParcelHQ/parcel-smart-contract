diff --git a/allowances/contracts/AlowanceModule.sol b/allowances/contracts/AlowanceModule.sol
index be7dfe1385f91499f1842fb38093487d6b541c98..8d559ab2474f302e9c91b5ae7766f2836afa6556 100644
--- a/allowances/contracts/AlowanceModule.sol
+++ b/allowances/contracts/AlowanceModule.sol
@@ -1,8 +1,20 @@
 // SPDX-License-Identifier: LGPL-3.0-only
 pragma solidity >=0.7.0 <0.8.0;
+pragma experimental ABIEncoderV2;
 
 import "./Enum.sol";
 import "./SignatureDecoder.sol";
+import "./interfaces/AggregatorV3Interface.sol";
+import "./lib/DSMath.sol";
+import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import "@openzeppelin/contracts/access/Ownable.sol";
+
+interface IERC20Decimal is IERC20{
+    /**
+     * @dev Returns the amount of tokens in existence.
+     */
+    function decimals() external view returns (uint256);
+}
 
 interface GnosisSafe {
     /// @dev Allows a Module to execute a Safe transaction without any further confirmations.
@@ -15,11 +27,15 @@ interface GnosisSafe {
         returns (bool success);
 }
 
-contract AllowanceModule is SignatureDecoder {
+contract AllowanceModule is SignatureDecoder, Ownable, DSMath {
 
     string public constant NAME = "Allowance Module";
     string public constant VERSION = "0.1.0";
 
+    // solhint-disable-next-line var-name-mixedcase
+    address payable public GELATO;
+    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
+
     bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;
     // keccak256(
     //     "EIP712Domain(uint256 chainId,address verifyingContract)"
@@ -32,12 +48,16 @@ contract AllowanceModule is SignatureDecoder {
 
     // Safe -> Delegate -> Allowance
     mapping(address => mapping (address => mapping(address => Allowance))) public allowances;
+    // Safe -> maxGasPrice
+    mapping(address => uint256) public maxGasPrice;
     // Safe -> Delegate -> Tokens
     mapping(address => mapping (address => address[])) public tokens;
     // Safe -> Delegates double linked list entry points
     mapping(address => uint48) public delegatesStart;
     // Safe -> Delegates double linked list
     mapping(address => mapping (uint48 => Delegate)) public delegates;
+    // token -> chainlinkOracle
+    mapping(address => address) public tokenToOracle;
 
     // We use a double linked list for the delegates. The id is the first 6 bytes. 
     // To double check the address in case of collision, the address is part of the struct.
@@ -54,8 +74,11 @@ contract AllowanceModule is SignatureDecoder {
         uint16 resetTimeMin; // Maximum reset time span is 65k minutes
         uint32 lastResetMin;
         uint16 nonce;
+        int256 endsOn;
     }
 
+    int256 public immutable notEndsOn = -1;
+
     event AddDelegate(address indexed safe, address delegate);
     event RemoveDelegate(address indexed safe, address delegate);
     event ExecuteAllowanceTransfer(address indexed safe, address delegate, address token, address to, uint96 value, uint16 nonce);
@@ -63,6 +86,13 @@ contract AllowanceModule is SignatureDecoder {
     event SetAllowance(address indexed safe, address delegate, address token, uint96 allowanceAmount, uint16 resetTime);
     event ResetAllowance(address indexed safe, address delegate, address token);
     event DeleteAllowance(address indexed safe, address delegate, address token);
+    event NewMaxGasPrice(address indexed safe, uint256 newMaxGasPrice);
+    event AddTokenOracle(address indexed token, address indexed oracle);
+    event SetGelatoAddress(address indexed gelato);
+
+    constructor(address payable _gelato) {
+        GELATO = _gelato;
+    }
 
     /// @dev Allows to update the allowance for a specified token. This can only be done via a Safe transaction.
     /// @param delegate Delegate whose allowance should be updated.
@@ -70,7 +100,10 @@ contract AllowanceModule is SignatureDecoder {
     /// @param allowanceAmount allowance in smallest token unit.
     /// @param resetTimeMin Time after which the allowance should reset
     /// @param resetBaseMin Time based on which the reset time should be increased
-    function setAllowance(address delegate, address token, uint96 allowanceAmount, uint16 resetTimeMin, uint32 resetBaseMin)
+    function setAllowance(
+        address delegate, address token, uint96 allowanceAmount, int256 fiatAmount, 
+        uint16 resetTimeMin, uint32 resetBaseMin, int256 endsOn
+    )
         public
     {
         require(delegate != address(0), "delegate != address(0)");
@@ -91,11 +124,49 @@ contract AllowanceModule is SignatureDecoder {
             allowance.lastResetMin = currentMin;
         }
         allowance.resetTimeMin = resetTimeMin;
-        allowance.amount = allowanceAmount;
+
+        if (allowanceAmount != 0) {
+            allowance.amount = allowanceAmount;
+        } else {
+            require(fiatAmount != 0, "Fiat Amount Can't be Zero");
+            require(tokenToOracle[token] != address(0), "Oracle not specified for this token");
+            uint96 tokenQuantity = getTokenQuantity(fiatAmount, token, tokenToOracle[token]);
+            require(tokenQuantity != 0, "Token Quantity Can't be Zero");
+            allowance.amount = tokenQuantity;
+        }
+
+        if (endsOn > 0) {
+            allowance.endsOn = endsOn;
+        } else {
+            allowance.endsOn = notEndsOn;
+        }
+
         updateAllowance(msg.sender, delegate, token, allowance);
         emit SetAllowance(msg.sender, delegate, token, allowanceAmount, resetTimeMin);
     }
 
+    // calculate token quantity from fiat amount
+    function getTokenQuantity(int256 fiatAmount, address token, address _oracle)
+        public view returns(uint96 tokenQuantity)
+    {
+        // Call Chainlink to fetch price and priceDecimals
+        (int tokenPrice, uint256 priceDecimals) = getLatestPrice(_oracle);
+        uint256 tokenDecimals = IERC20Decimal(token).decimals();
+
+        fiatAmount = fiatAmount * int256(10 ** priceDecimals);
+        tokenQuantity = uint96(wdiv(uint(fiatAmount), uint(tokenPrice)));
+        if (tokenDecimals != 18) {
+            tokenQuantity = uint96(tokenQuantity * (10 ** tokenDecimals) / (10 ** 18));
+        }
+    }
+
+    // chainlink price integration
+    function getLatestPrice(address _oracle) public view returns (int, uint8) {
+        (,int price,,,) = AggregatorV3Interface(_oracle).latestRoundData();
+        uint8 decimals = AggregatorV3Interface(_oracle).decimals();
+        return (price, decimals);
+    }
+
     function getAllowance(address safe, address delegate, address token) private view returns (Allowance memory allowance) {
         allowance = allowances[safe][delegate][token];
         // solium-disable-next-line security/no-block-members
@@ -143,7 +214,6 @@ contract AllowanceModule is SignatureDecoder {
     /// @param token Token contract address.
     /// @param to Address that should receive the tokens.
     /// @param amount Amount that should be transferred.
-    /// @param paymentToken Token that should be used to pay for the execution of the transfer.
     /// @param payment Amount to should be paid for executing the transfer.
     /// @param delegate Delegate whose allowance should be updated.
     /// @param signature Signature generated by the delegate to authorize the transfer.
@@ -152,14 +222,18 @@ contract AllowanceModule is SignatureDecoder {
         address token,
         address payable to,
         uint96 amount,
-        address paymentToken,
         uint96 payment,
         address delegate,
         bytes memory signature
     ) public {
         // Get current state
         Allowance memory allowance = getAllowance(address(safe), delegate, token);
-        bytes memory transferHashData = generateTransferHashData(address(safe), token, to, amount, paymentToken, payment, allowance.nonce);
+        bytes memory transferHashData = generateTransferHashData(address(safe), token, to, amount, allowance.nonce);
+
+        if (allowance.endsOn != notEndsOn) {
+            require(allowance.endsOn > 0, "This address's recurring expired.");
+            allowance.endsOn = allowance.endsOn - 1;
+        }
 
         // Update state
         allowance.nonce = allowance.nonce + 1;
@@ -167,16 +241,6 @@ contract AllowanceModule is SignatureDecoder {
         // Check new spent amount and overflow
         require(newSpent > allowance.spent && newSpent <= allowance.amount, "newSpent > allowance.spent && newSpent <= allowance.amount");
         allowance.spent = newSpent;
-        if (payment > 0) {
-            // Use updated allowance if token and paymentToken are the same
-            Allowance memory paymentAllowance = paymentToken == token ? allowance : getAllowance(address(safe), delegate, paymentToken);
-            newSpent = paymentAllowance.spent + payment;
-            // Check new spent amount and overflow
-            require(newSpent > paymentAllowance.spent && newSpent <= paymentAllowance.amount, "newSpent > paymentAllowance.spent && newSpent <= paymentAllowance.amount");
-            paymentAllowance.spent = newSpent;
-            // Update payment allowance if different from allowance
-            if (paymentToken != token) updateAllowance(address(safe), delegate, paymentToken, paymentAllowance);
-        }
         updateAllowance(address(safe), delegate, token, allowance);
 
         // Perform external interactions
@@ -184,17 +248,42 @@ contract AllowanceModule is SignatureDecoder {
         checkSignature(delegate, signature, transferHashData, safe);
 
         if (payment > 0) {
+            require(tx.gasprice <= maxGasPrice[address(safe)], "tx.gasprice is > maxGas price");
+            require(payment <= maxGasPrice[address(safe)] * 1e6, "Gas fees > allowed"); // deterministic gas calculation
             // Transfer payment
             // solium-disable-next-line security/no-tx-origin
-            transfer(safe, paymentToken, tx.origin, payment);
+            transfer(safe, ETH, GELATO, payment);
             // solium-disable-next-line security/no-tx-origin
-            emit PayAllowanceTransfer(address(safe), delegate, paymentToken, tx.origin, payment);
+            emit PayAllowanceTransfer(address(safe), delegate, ETH, tx.origin, payment);
         }
         // Transfer token
         transfer(safe, token, to, amount);
         emit ExecuteAllowanceTransfer(address(safe), delegate, token, to, amount, allowance.nonce - 1);
     }
 
+    /// @dev Allows to use the allowance to perform a transfer to multiple users.
+    /// @param safe The Safe whose funds should be used.
+    /// @param token Token contract address.
+    /// @param to Address that should receive the tokens.
+    /// @param amount Amount that should be transferred.
+    /// @param payment Amount to should be paid for executing the transfer.
+    /// @param delegate Delegate whose allowance should be updated.
+    /// @param signature Signature generated by the delegate to authorize the transfer.
+    function multipleExecuteAllowanceTransfer(
+        GnosisSafe[] memory safe,
+        address[] memory token,
+        address[] memory to,
+        uint96[] memory amount,
+        uint96[] memory payment,
+        address[] memory delegate,
+        bytes[] memory signature
+    ) public {
+        uint256 countToIterate = amount.length;
+        for (uint i=0; i<countToIterate; i++) {
+            executeAllowanceTransfer(safe[i], token[i], payable(to[i]), amount[i], payment[i], delegate[i], signature[i]);
+        }
+    }
+
     /// @dev Returns the chain id used by this contract.
     function getChainId() public pure returns (uint256) {
         uint256 id;
@@ -211,14 +300,12 @@ contract AllowanceModule is SignatureDecoder {
         address token,
         address to,
         uint96 amount,
-        address paymentToken,
-        uint96 payment,
         uint16 nonce
     ) private view returns (bytes memory) {
         uint256 chainId = getChainId();
         bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this));
         bytes32 transferHash = keccak256(
-            abi.encode(ALLOWANCE_TRANSFER_TYPEHASH, safe, token, to, amount, paymentToken, payment, nonce)
+            abi.encode(ALLOWANCE_TRANSFER_TYPEHASH, safe, token, to, amount, ETH, nonce)
         );
         return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, transferHash);
     }
@@ -229,19 +316,17 @@ contract AllowanceModule is SignatureDecoder {
         address token,
         address to,
         uint96 amount,
-        address paymentToken,
-        uint96 payment,
         uint16 nonce
     ) public view returns (bytes32) {
         return keccak256(generateTransferHashData(
-            safe, token, to, amount, paymentToken, payment, nonce
+            safe, token, to, amount, nonce
         ));
     }
 
     function checkSignature(address expectedDelegate, bytes memory signature, bytes memory transferHashData, GnosisSafe safe) private view {
         address signer = recoverSignature(signature, transferHashData);
         require(
-            expectedDelegate == signer && delegates[address(safe)][uint48(signer)].delegate == signer,
+            (expectedDelegate == signer && delegates[address(safe)][uint48(signer)].delegate == signer) || msg.sender == GELATO,
             "expectedDelegate == signer && delegates[address(safe)][uint48(signer)].delegate == signer"
         );
     }
@@ -274,7 +359,8 @@ contract AllowanceModule is SignatureDecoder {
     }
 
     function transfer(GnosisSafe safe, address token, address payable to, uint96 amount) private {
-        if (token == address(0)) {
+        // if (token == address(0) || token == ETH) {
+        if (token == ETH) {
             // solium-disable-next-line security/no-send
             require(safe.execTransactionFromModule(to, amount, "", Enum.Operation.Call), "Could not execute ether transfer");
         } else {
@@ -317,6 +403,13 @@ contract AllowanceModule is SignatureDecoder {
         emit AddDelegate(msg.sender, delegate);
     }
 
+    /// @dev Allows to add a set max gas price for user
+    /// @param newMaxGasPrice New Max Gas Price to set.
+    function setMaxGasPrice(uint256 newMaxGasPrice) public {
+        maxGasPrice[msg.sender] = newMaxGasPrice;
+        emit NewMaxGasPrice(msg.sender, newMaxGasPrice);
+    }
+
     /// @dev Allows to remove a delegate.
     /// @param delegate Delegate that should be removed.
     /// @param removeAllowances Indicator if allowances should also be removed. This should be set to `true` unless this causes an out of gas, in this case the allowances should be "manually" deleted via `deleteAllowance`.
@@ -367,4 +460,14 @@ contract AllowanceModule is SignatureDecoder {
             mstore(results, i)
         }
     }
-}
\ No newline at end of file
+
+    function addTokenOracle(address token, address oracle) public onlyOwner {
+        tokenToOracle[token] = oracle;
+        emit AddTokenOracle(token, oracle);
+    }
+
+    function setGelatoAddress(address payable gelato) public onlyOwner {
+        GELATO = gelato;
+        emit SetGelatoAddress(gelato);
+    }
+}
